// content.js

console.log(`AI Privacy Guard content script loaded on page: ${location.href}`);

// Bridge: handle in-page sanitize requests (inpage.js -> content.js -> service)
try {
    const NS = 'aipg';
    if (!(window).__aipgBridge) {
        (window).__aipgBridge = true;
        // Support both postMessage and legacy CustomEvent bridges
        const handlePayload = async (data, respond) => {
            try {
                if (!data || data.ns !== NS) return;
                if (!(data.type === 'SANITIZE_PRE_REQ' || data.type === 'SANITIZE_PRE')) return;
                const id = data.id;
                const body = data.body;
                const flags = await new Promise(resolve => chrome.storage.local.get(['sessionSanitizerEnabled', 'alwaysMaskEnabled'], r => resolve(r)));
                if (flags && flags.sessionSanitizerEnabled === false) { respond({ ns: NS, id, type: 'SANITIZE_PRE_RESP', ok: false }); return; }
                const catList = detectSensitiveCategory(location.hostname, location.href);
                const siteCategory = catList && catList.length ? catList[0] : 'general';
                const ctx = { origin: (new URL(location.href)).origin, processing: 'unknown', trackersPresent: detectTrackers(), siteCategory, tabId: undefined };
                const mod = await import(chrome.runtime.getURL('services/session/outboundGuard.js'));
                const { preflightRewrite } = mod;
                const res = await preflightRewrite(body, { ...ctx, sessionId: (window.__aipgSessionId || (window.__aipgSessionId = (self.crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now())))) });
                if (res && res.rewritten !== undefined) respond({ ns: NS, id, type: 'SANITIZE_PRE_RESP', ok: true, body: res.rewritten });
                else respond({ ns: NS, id, type: 'SANITIZE_PRE_RESP', ok: false });
            } catch (e) {
                try { respond({ ns: NS, id: (data && data.id), type: 'SANITIZE_PRE_RESP', ok: false }); } catch (e2) { }
            }
        };

        window.addEventListener('message', async (e) => {
            try {
                if (e.source !== window) return;
                const data = e && (e.data);
                if (!data || data.__handledByAipg) return;
                await handlePayload(data, (resp) => window.postMessage({ ...resp, __handledByAipg: true }, '*'));
            } catch (e) { }
        }, true);

        const BRIDGE_EVENT = 'AIPG_BRIDGE_EVENT';
        const RESP_EVENT = 'AIPG_BRIDGE_RESP';
        window.addEventListener(BRIDGE_EVENT, async (e) => {
            const data = e && (e.detail || e.data);
            await handlePayload(data, (resp) => window.dispatchEvent(new CustomEvent(RESP_EVENT, { detail: resp })));
        }, true);
    }
} catch (e) { }

// Lightweight network observers to record POSTs (active usage) without modifying requests
try {
    (function () {
        const w = window;
        if (w.__aipgPatched) return;
        w.__aipgPatched = true;
        // Inject in-page patcher early (runs in page JS context)
        try {
            const s = document.createElement('script');
            s.src = chrome.runtime.getURL('inpage.js');
            s.dataset.aipg = '1';
            (document.documentElement || document.head || document.body).appendChild(s);
            // Remove tag node after load to avoid DOM clutter
            s.onload = () => { try { s.remove(); } catch (e) { } };
        } catch (e) { }
        w.__aipgSignals = w.__aipgSignals || { posts: [], ws: [] };
        // fetch
        const origFetch = w.fetch;
        if (typeof origFetch === 'function') {
            const sessionId = self.crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now());
            w.fetch = async function (input, init) {
                let theInput = input;
                let theInit = init ? { ...init } : undefined;
                try {
                    const method = ((theInit && theInit.method) || (typeof theInput !== 'string' && theInput && theInput.method) || 'GET').toUpperCase();
                    const url = typeof theInput === 'string' ? theInput : (theInput && theInput.url) || '';
                    if (method === 'POST') {
                        w.__aipgSignals.posts.push({ url, ts: Date.now() });
                    }
                    // Outbound pre-send sanitizer (safe, strings/JSON only)
                    const flags = await new Promise(resolve => chrome.storage.local.get(['sessionSanitizerEnabled', 'alwaysMaskEnabled'], r => resolve(r)));
                    if (flags && flags.sessionSanitizerEnabled !== false) {
                        const bodyCandidate = theInit && theInit.body;
                        if (typeof url === 'string' && (typeof bodyCandidate === 'string' || typeof bodyCandidate === 'object')) {
                            try {
                                const catList = detectSensitiveCategory(location.hostname, location.href);
                                const siteCategory = catList && catList.length ? catList[0] : 'general';
                                const ctx = { origin: (new URL(location.href)).origin, processing: 'unknown', trackersPresent: detectTrackers(), siteCategory, tabId: undefined };
                                const mod = await import(chrome.runtime.getURL('services/session/outboundGuard.js'));
                                const { preflightRewrite } = mod;
                                const res = await preflightRewrite(bodyCandidate, { ...ctx, sessionId });
                                if (res && res.rewritten !== undefined) {
                                    const always = !!(flags && flags.alwaysMaskEnabled !== false);
                                    if (!always) {
                                        // Optional pre-send UI: highlight risky pieces and let user confirm masking.
                                        try {
                                            const ui = buildOutboundMaskUI(res.original, res.rewritten, res.redactions || []);
                                            if (ui) {
                                                const decision = await ui.waitForDecision();
                                                ui.cleanup();
                                                if (decision === 'cancel') throw new Error('User canceled outbound send');
                                            }
                                        } catch (e) { }
                                    }
                                    // If object, stringify; else use as-is
                                    const newBody = (typeof res.rewritten === 'object') ? JSON.stringify(res.rewritten) : String(res.rewritten);
                                    theInit = { ...(theInit || {}), body: newBody };
                                }
                            } catch (e) { /* best-effort */ }
                        }
                    }
                } catch (e) { }
                // @ts-ignore
                const resp = await origFetch.apply(this, [theInput, theInit]);
                try {
                    // Inbound post-receive inspector (monitor-only; we do not rewrite response to avoid breakage)
                    const flags2 = await new Promise(resolve => chrome.storage.local.get(['sessionSanitizerEnabled'], r => resolve(r)));
                    if (flags2 && flags2.sessionSanitizerEnabled !== false) {
                        const ct = (resp.headers && resp.headers.get && resp.headers.get('content-type')) || '';
                        if (/text|json|html/i.test(ct)) {
                            const clone = resp.clone();
                            const text = await clone.text();
                            const catList = detectSensitiveCategory(location.hostname, location.href);
                            const siteCategory = catList && catList.length ? catList[0] : 'general';
                            const ctx = { origin: (new URL(location.href)).origin, processing: 'unknown', trackersPresent: detectTrackers(), siteCategory, tabId: undefined };
                            try {
                                const mod2 = await import(chrome.runtime.getURL('services/session/inboundGuard.js'));
                                const { inspectResponseBody } = mod2;
                                const outcome = await inspectResponseBody(text, ct, { ...ctx, sessionId });
                                try { renderInboundSignalBanner(outcome && outcome.malicious === false); } catch (e) { }
                            } catch (e) { }
                        }
                    }
                } catch (e) { }
                return resp;
            };
        }
        // XHR
        if (w.XMLHttpRequest) {
            const origOpen = w.XMLHttpRequest.prototype.open;
            const origSend = w.XMLHttpRequest.prototype.send;
            w.XMLHttpRequest.prototype.open = function (method, url) {
                try { this.__aipgMethod = String(method || 'GET').toUpperCase(); this.__aipgUrl = String(url || ''); } catch (e) { }
                return origOpen.apply(this, arguments);
            };
            w.XMLHttpRequest.prototype.send = function (body) {
                try {
                    if (this.__aipgMethod === 'POST') {
                        w.__aipgSignals.posts.push({ url: this.__aipgUrl || '', ts: Date.now(), bodySize: typeof body === 'string' ? body.length : 0 });
                    }
                } catch (e) { }
                return origSend.apply(this, arguments);
            };
        }
    })();
} catch (e) { }

// Input-level proactive PII redaction (ChatGPT only) with modal (Send Redacted | Send Raw | Cancel)
try {
    (function () {
        const host = location.hostname;
        const isChatGPT = /(^|\.)openai\.com$/i.test(host) || /(^|\.)chatgpt\.com$/i.test(host);
        if (!isChatGPT) return;
        const DEBUG = false;
        const log = (...a) => { if (DEBUG) console.warn('[AIPG-CHATGPT]', ...a); };

        // Shadow-DOM aware query
        function queryDeep(selectors) {
            const seen = new Set();
            function collect(root) {
                if (!root || seen.has(root)) return;
                seen.add(root);
                try { root.querySelectorAll('*').forEach(el => { if (el.shadowRoot) collect(el.shadowRoot); }); } catch { }
            }
            collect(document);
            for (const sel of selectors) {
                for (const root of seen) {
                    try { const found = root.querySelector(sel); if (found) return found; } catch { }
                }
            }
            return null;
        }

        // Reliable composer detection
        function findChatGPTInput() {
            const tries = [
                'textarea#prompt-textarea',
                'textarea[data-testid="prompt-textarea"]',
                'main div[contenteditable="true"]'
            ];
            const el = queryDeep(tries);
            if (el) return el;
            // Fallback: last contenteditable on page
            const eds = document.querySelectorAll('[contenteditable="true"]');
            return eds.length ? eds[eds.length - 1] : null;
        }

        // Helpers
        function dispatchEnter(el) {
            const ev = { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true, cancelable: true };
            try { el.dispatchEvent(new KeyboardEvent('keydown', ev)); } catch { }
            try { el.dispatchEvent(new KeyboardEvent('keyup', ev)); } catch { }
        }
        function getValue(el) { try { return el?.isContentEditable ? (el.innerText || el.textContent || '') : (el?.value || ''); } catch { return ''; } }
        // Use native setters so React/Preact controlled inputs update internal state
        function setValue(el, v) {
            try {
                if (!el) return;
                if (el.isContentEditable) {
                    // Update contenteditable and fire an input event similar to paste
                    el.innerText = v;
                    try { el.dispatchEvent(new InputEvent('input', { bubbles: true, cancelable: true, inputType: 'insertFromPaste', data: v })); } catch { el.dispatchEvent(new Event('input', { bubbles: true })); }
                    return;
                }
                const tag = (el.tagName || '').toLowerCase();
                if (tag === 'textarea') {
                    const desc = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value');
                    if (desc && desc.set) desc.set.call(el, v); else el.value = v;
                } else if (tag === 'input') {
                    const desc = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
                    if (desc && desc.set) desc.set.call(el, v); else el.value = v;
                } else {
                    el.value = v;
                }
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
            } catch { }
        }

        // Click the send button if available (more reliable than synthetic Enter)
        function findSendButton() {
            const tries = [
                'button[data-testid="send-button"]',
                'button[aria-label*="send" i]',
                'button[aria-label="Send message" i]',
                'button[aria-label="Send" i]',
                'form button[type="submit"]',
                'button[aria-label*="Submit" i]'
            ];
            const btn = queryDeep(tries);
            if (btn) return btn;
            // Fallback: search common buttons and heuristics
            try {
                const cands = Array.from(document.querySelectorAll('button'));
                return cands.find(b => /send|submit/i.test(b.getAttribute('aria-label') || b.textContent || '')) || null;
            } catch { return null; }
        }
        function clickSend() {
            const btn = findSendButton();
            if (btn) { try { btn.click(); return true; } catch { } }
            return false;
        }

        // tiny waits to allow frameworks to sync state before submit
        const wait = (ms) => new Promise(r => setTimeout(r, ms));
        const nextFrame = () => new Promise(r => requestAnimationFrame(() => r()))

        // Minimal MVP redactor (email + phone only) with placeholders
        const EMAIL_REGEX = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi;
        const PHONE_REGEX = /\b\d{7,15}\b/g;
        function redactPII(text) {
            try {
                return String(text || '')
                    .replace(EMAIL_REGEX, '[REDACTED_EMAIL]')
                    .replace(PHONE_REGEX, '[REDACTED_PHONE]');
            } catch { return String(text || ''); }
        }
        function quickPIIHit(s) {
            try {
                const str = String(s || '');
                return (str.match(EMAIL_REGEX) || []).length > 0 || (str.match(PHONE_REGEX) || []).length > 0;
            } catch { return false; }
        }

        // Modal (shadow DOM, safe preview)
        const MODAL_ID = 'aipg-modal-root';
        let modalOpen = false;
        function countsFromRedactions(list) {
            const c = { EMAIL: 0, PHONE: 0, CARD: 0, APIKEY: 0 };
            try { (list || []).forEach(r => { if (r && r.type && c.hasOwnProperty(r.type)) c[r.type]++; }); } catch { }
            return c;
        }
        function showChoiceModal({ original, redacted, counts, onRedacted, onRaw, onCancel }) {
            if (modalOpen) return () => { };
            modalOpen = true;
            const root = document.getElementById(MODAL_ID) || document.createElement('div');
            root.id = MODAL_ID;
            document.documentElement.appendChild(root);
            const shadow = root.shadowRoot || root.attachShadow({ mode: 'open' });
            const css = `:host{all:initial}*,*::before,*::after{box-sizing:border-box}.a{position:fixed;inset:0;z-index:2147483646;display:grid;place-items:center;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}.b{position:absolute;inset:0;background:rgba(17,24,39,.45);backdrop-filter:saturate(120%) blur(2px)}.c{position:relative;max-width:680px;width:min(96vw,680px);max-height:min(85vh,720px);overflow:auto;background:#fff;border-radius:12px;box-shadow:0 20px 40px rgba(0,0,0,.25),0 0 0 1px rgba(0,0,0,.06);padding:16px;display:flex;flex-direction:column;gap:12px;color:#111827}.h{display:flex;align-items:center;gap:10px}.i{font-size:20px;line-height:1}.t{margin:0;font-size:16px;font-weight:600}.s{margin:0 0 6px 0;color:#4b5563;font-size:12px}.pv{display:block;width:100%;min-height:100px;max-height:220px;resize:vertical;border:1px solid #e5e7eb;border-radius:8px;padding:10px 12px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.4;background:#f9fafb;color:#111827;overflow:auto}.lab{font-size:11px;color:#6b7280}.cnt{font-size:12px;color:#374151;white-space:nowrap}.act{position:sticky;bottom:0;background:#fff;display:flex;gap:8px;justify-content:flex-end;margin-top:4px;padding-top:8px}.btn{appearance:none;border:1px solid #e5e7eb;background:#fff;color:#111827;border-radius:8px;padding:8px 12px;font-size:12px;cursor:pointer;transition:background .12s ease,border-color .12s ease,transform .05s ease}.btn:focus{outline:2px solid #3b82f6;outline-offset:2px}.btn:hover{background:#f3f4f6}.btn:active{transform:translateY(1px)}.ok{background:#111827;color:#fff;border-color:#111827}.ok:hover{background:#1f2937}.raw{background:#fef3c7;color:#78350f;border-color:#fde68a}.raw:hover{background:#fde68a}`;
            shadow.innerHTML = '';
            const style = document.createElement('style'); style.textContent = css; shadow.appendChild(style);
            const wrap = document.createElement('div'); wrap.className = 'a';
            wrap.innerHTML = `<div class="b"></div><div class="c" role="dialog" aria-modal="true" aria-labelledby="x"><div class="h"><div class="i" aria-hidden="true">⚠️</div><h2 id="x" class="t">You are sharing personal information</h2></div><p class="s">Choose which version to send.</p><div><div class="lab">Original</div><textarea class="pv pv-o" readonly></textarea></div><div><div class="lab">Redacted</div><textarea class="pv pv-r" readonly></textarea></div><div class="cnt"></div><div class="act"><button class="btn ok" data-a="red">Send Redacted</button><button class="btn raw" data-a="raw">Send Original</button><button class="btn" data-a="cancel">Cancel</button></div></div>`;
            shadow.appendChild(wrap);
            const prevO = shadow.querySelector('.pv-o');
            const prevR = shadow.querySelector('.pv-r');
            const cnt = shadow.querySelector('.cnt');
            prevO.value = original || '';
            prevR.value = redacted || '';
            cnt.textContent = `{ EMAIL: ${counts.EMAIL}, PHONE: ${counts.PHONE}, CARD: ${counts.CARD}, APIKEY: ${counts.APIKEY} }`;
            const close = () => { try { wrap.remove(); } catch { } try { root.remove(); } catch { } modalOpen = false; };
            shadow.querySelector('.b')?.addEventListener('click', close);
            shadow.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
            shadow.querySelectorAll('[data-a]')?.forEach(btn => btn.addEventListener('click', () => {
                const act = btn.getAttribute('data-a');
                if (act === 'red') onRedacted?.();
                else if (act === 'raw') onRaw?.();
                else onCancel?.();
                close();
            }));
            // focus first
            (shadow.querySelector('[data-a]'))?.focus();
            return close;
        }

        // Intercept explicit send-button clicks to ensure modal always appears
        function wireSendButton(btn) {
            if (!btn || btn.__aipgBtnWired) return;
            btn.__aipgBtnWired = true;
            btn.addEventListener('click', (e) => {
                try {
                    if (btn.__aipgBypassNextClick) { btn.__aipgBypassNextClick = false; return; }
                    const el = findChatGPTInput();
                    if (!el) return;
                    const original = getValue(el);
                    if (!original) return; // let it send empty or non-PII
                    const redacted = redactPII(original);
                    if (original === redacted) return; // no PII, allow

                    // PII found: show modal and stop this click
                    e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
                    const counts = { EMAIL: (original.match(EMAIL_REGEX) || []).length, PHONE: (original.match(PHONE_REGEX) || []).length, CARD: 0, APIKEY: 0 };
                    try {
                        chrome.runtime.sendMessage({ type: 'PII_FOUND', chatId: getSessionId(), messageId: (crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now())), link: conversationUrlFromLocation(), site: location.hostname, counts });
                    } catch { }
                    showChoiceModal({
                        original,
                        redacted,
                        counts,
                        onRedacted: async () => {
                            setValue(el, redacted);
                            await nextFrame();
                            await wait(60);
                            btn.__aipgBypassNextClick = true;
                            try { btn.click(); } catch { dispatchEnter(el); }
                        },
                        onRaw: async () => {
                            // Log prompt (raw allowed). Store redacted excerpt only.
                            try {
                                const site = location.hostname;
                                const cu = conversationUrlFromLocation();
                                const excerpt = safeExcerptRedacted(String(original || '')).slice(0, 240);
                                const piiCounts = { EMAIL: (original.match(EMAIL_REGEX) || []).length, PHONE: (original.match(PHONE_REGEX) || []).length, CARD: 0, APIKEY: 0 };
                                const id = (self.crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : String(Date.now());
                                chrome.runtime.sendMessage({ type: 'MEMORY_WRITE', record: { id, ts: Date.now(), site, conversationUrl: cu, origin: location.origin, sessionId: getSessionId(), direction: 'prompt', rawAllowed: true, excerpt, piiCounts } });
                            } catch { }
                            await nextFrame();
                            btn.__aipgBypassNextClick = true;
                            try { btn.click(); } catch { dispatchEnter(el); }
                        },
                        onCancel: () => { /* keep editing, no side effects */ }
                    });
                } catch { }
            }, true);
        }

        // Debounce helper
        function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

        function conversationUrlFromLocation() {
            try {
                const u = new URL(location.href);
                // chat.openai.com or chatgpt.com conversation path
                const m = u.pathname.match(/\/c\/([0-9a-f\-]{10,})/i);
                if (m) return `${u.origin}/c/${m[1]}`;
                return u.href;
            } catch { return location.href; }
        }

        function safeExcerptRedacted(text) {
            try {
                const EMAIL_REGEX = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi;
                const PHONE_REGEX = /\b\d{7,15}\b/g;
                return String(text || '')
                    .replace(EMAIL_REGEX, '[REDACTED_EMAIL]')
                    .replace(PHONE_REGEX, '[REDACTED_PHONE]');
            } catch { return String(text || ''); }
        }

        function getSessionId() {
            try {
                if (window.__aipgSessionId) return String(window.__aipgSessionId);
                // Try to derive from conversation id
                const cu = conversationUrlFromLocation();
                const m = cu.match(/\/c\/([0-9a-f\-]{10,})/i);
                const sid = m ? m[1] : (self.crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
                window.__aipgSessionId = sid;
                return sid;
            } catch { return String(Date.now()); }
        }

        async function handleDecision(el, kind, sanitized) {
            try {
                if (kind === 'redacted') {
                    setValue(el, sanitized);
                    // Let framework update internal state fully
                    await nextFrame();
                    await wait(60);
                    // Do not create memory records for redacted sends (user wants only originals logged)
                    if (!clickSend()) dispatchEnter(el);
                } else if (kind === 'raw') {
                    // Log prompt (raw selection, but store redacted excerpt)
                    try {
                        const site = location.hostname;
                        const cu = conversationUrlFromLocation();
                        const original = getValue(el);
                        const excerpt = safeExcerptRedacted(String(original || '')).slice(0, 240);
                        const piiCounts = { EMAIL: (original.match(EMAIL_REGEX) || []).length, PHONE: (original.match(PHONE_REGEX) || []).length, CARD: 0, APIKEY: 0 };
                        const id = (self.crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : String(Date.now());
                        chrome.runtime.sendMessage({ type: 'MEMORY_WRITE', record: { id, ts: Date.now(), site, conversationUrl: cu, origin: location.origin, sessionId: getSessionId(), direction: 'prompt', rawAllowed: true, excerpt, piiCounts } });
                    } catch { }
                    if (!clickSend()) dispatchEnter(el);
                }
            } catch (e) { log('decision err', e); }
        }

        function runScan(el, trigger) {
            return new Promise((resolve) => {
                // Only act on actual send attempts; do not alter text while typing
                if (trigger !== 'enter' && trigger !== 'keyup') return resolve();
                const original = getValue(el);
                if (!original) { dispatchEnter(el); return resolve(); }
                const redacted = redactPII(original);
                if (original === redacted) { dispatchEnter(el); return resolve(); }

                // Always show modal for user choice; do not auto-send
                const counts = { EMAIL: (original.match(EMAIL_REGEX) || []).length, PHONE: (original.match(PHONE_REGEX) || []).length, CARD: 0, APIKEY: 0 };
                // Record a lightweight index so the panel can show which chats had PII
                try {
                    chrome.runtime.sendMessage({
                        type: 'PII_FOUND',
                        chatId: getSessionId(),
                        messageId: (crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now())),
                        link: conversationUrlFromLocation(),
                        site: location.hostname,
                        counts
                    });
                } catch { }
                showChoiceModal({
                    original,
                    redacted,
                    counts,
                    onRedacted: () => Promise.resolve(handleDecision(el, 'redacted', redacted)).then(() => resolve()),
                    onRaw: () => Promise.resolve(handleDecision(el, 'raw')).then(() => resolve()),
                    onCancel: () => { /* keep editing */ resolve(); }
                });
            });
        }

        function wire(el) {
            if (!el || el.__aipgWired) return;
            el.__aipgWired = true;
            el.__aipgSendGuard = false;
            // While typing, do not modify or open modal; no passive actions
            const noop = () => { };
            el.addEventListener('input', noop, true);
            el.addEventListener('paste', noop, true);
            el.addEventListener('blur', noop, true);
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    if (modalOpen || el.__aipgSendGuard) { e.preventDefault(); e.stopPropagation(); return; }
                    e.preventDefault(); e.stopPropagation();
                    el.__aipgSendGuard = true;
                    runScan(el, 'enter')
                        .finally(() => { el.__aipgSendGuard = false; });
                }
            }, true);
            // Some variants submit on keyup
            el.addEventListener('keyup', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !modalOpen && !el.__aipgSendGuard) {
                    e.preventDefault(); e.stopPropagation();
                    el.__aipgSendGuard = true;
                    runScan(el, 'keyup')
                        .finally(() => { el.__aipgSendGuard = false; });
                }
            }, true);
        }

        function seed() { const el = findChatGPTInput(); if (el) wire(el); const sb = findSendButton(); if (sb) wireSendButton(sb); }
        const mo = new MutationObserver(() => seed());
        seed();
        try { mo.observe(document.documentElement, { subtree: true, childList: true, attributes: false }); } catch { }
        // Ensure re-wiring on focus/visibility and periodically
        window.addEventListener('focus', seed, true);
        document.addEventListener('visibilitychange', seed, true);
        document.addEventListener('focusin', seed, true);
        if (!window.__aipgSeedInterval) {
            window.__aipgSeedInterval = setInterval(seed, 2000);
        }

        // ---------- Response logging (DOM-only) ----------
        function extractAssistantText(root) {
            try {
                const text = (root.innerText || root.textContent || '').trim();
                return text
                    .replace(/```[\s\S]*?```/g, m => m.replace(/[\s\S]/g, ''))
                    .replace(/\s+/g, ' ')
                    .slice(0, 500);
            } catch { return ''; }
        }
        function findAssistantContainers() {
            // Target ChatGPT chat message area; keep selectors broad+
            const tries = [
                'main [data-testid="conversation-turn"]',
                'main .group\/message',
                'main div[data-message-author-role="assistant"]',
                'main div[role="dialog"] article'
            ];
            const root = document.querySelector('main') || document.body;
            const nodes = [];
            tries.forEach(sel => { try { root.querySelectorAll(sel).forEach(n => nodes.push(n)); } catch { } });
            return nodes.length ? nodes : Array.from(root.querySelectorAll('[data-message-author-role="assistant"], article'));
        }
        function setupResponseObserver() {
            if (window.__aipgRespObs) return;
            const recent = new Set();
            const remember = (k) => { recent.add(k); if (recent.size > 30) recent.delete(Array.from(recent)[0]); };
            const obs = new MutationObserver((mutList) => {
                for (const m of mutList) {
                    const tgt = m.target instanceof Element ? m.target : null;
                    if (!tgt) continue;
                    // Heuristic: when assistant blocks change and contain non-empty text, log.
                    if (tgt.matches && (tgt.matches('[data-message-author-role="assistant"], article, [data-testid="conversation-turn"]'))) {
                        const txt = extractAssistantText(tgt);
                        const key = txt.slice(0, 120);
                        if (txt && !recent.has(key)) {
                            remember(key);
                            try {
                                const id = (self.crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : String(Date.now());
                                chrome.runtime.sendMessage({ type: 'MEMORY_WRITE', record: { id, ts: Date.now(), site: location.hostname, conversationUrl: conversationUrlFromLocation(), origin: location.origin, sessionId: getSessionId(), direction: 'response', excerpt: txt } });
                            } catch { }
                        }
                    }
                }
            });
            try {
                obs.observe(document.body, { subtree: true, childList: true, characterData: true });
                window.__aipgRespObs = obs;
            } catch { }
        }
        setupResponseObserver();
    })();
} catch (e) { }

function detectSensitiveCategory(hostname, href) {
    const cats = [];
    const h = String(hostname || '').toLowerCase();
    const u = String(href || '').toLowerCase();
    if (/\.gov$/.test(h) || /gov\b/.test(u)) cats.push('government');
    if (/bank|finance|pay|paypal|chase|boa|hsbc|citibank/.test(h + u)) cats.push('banking');
    if (/clinic|health|medical|patient|pharma|hospital/.test(h + u)) cats.push('healthcare');
    if (/\.edu$/.test(h) || /university|college|campus|edu\b/.test(u)) cats.push('education');
    if (/court|legal|law|attorney|bar\b/.test(h + u)) cats.push('legal');
    return Array.from(new Set(cats));
}

function detectFormsAndCredentials() {
    const hasForm = !!document.querySelector('form');
    const creds = !!document.querySelector('input[type="password"], input[name*="pass" i], input[name*="card" i], input[name*="ssn" i]');
    return { hasForm, creds };
}

function detectTrackers() {
    const patterns = [
        /google-analytics|googletagmanager|gtag/,
        /facebook|fbq|connect\.facebook\.net/,
        /segment|amplitude|mixpanel|hotjar|sentry/,
        /doubleclick|adservice|adroll/
    ];
    const urls = [];
    document.querySelectorAll('script[src], img[src], iframe[src]').forEach(el => {
        const src = el.getAttribute('src');
        if (src) urls.push(src);
    });
    return urls.some(u => patterns.some(p => p.test(u)));
}

function findPolicyLinkAbsolute() {
    try {
        const anchors = Array.from(document.querySelectorAll('a[href]'));
        const cand = anchors.find(a => /privacy|policy/i.test(a.textContent || '') || /privacy/i.test(a.getAttribute('href') || ''));
        if (!cand) return null;
        const href = cand.getAttribute('href');
        if (!href) return null;
        const url = new URL(href, location.href);
        return url.href;
    } catch (e) {
        return null;
    }
}

async function aiGuessPolicyLink() {
    try {
        const anyGlobal = /** @type {any} */(globalThis);
        if (!(anyGlobal && anyGlobal.ai && anyGlobal.ai.prompt && anyGlobal.ai.prompt.create)) return null;
        const anchors = Array.from(document.querySelectorAll('a[href]'))
            .map(a => ({ href: a.getAttribute('href') || '', text: (a.textContent || '').trim() }))
            .filter(x => x.href && !/^javascript:/i.test(x.href));
        if (anchors.length === 0) return null;
        const short = anchors.slice(0, 40); // limit prompt size
        const list = short.map((x, i) => `${i + 1}. ${x.text} -> ${x.href}`).join('\n');
        const session = await anyGlobal.ai.prompt.create();
        const q = `From the following links on a web page, select the one that most likely leads to the site's Privacy Policy. Respond with only the URL (absolute or relative) and nothing else. If none match, respond with "" (empty).\n\n${list}`;
        const answer = String(await session.prompt(q)).trim();
        if (!answer) return null;
        const href = answer.split(/\s+/)[0].trim();
        if (!href) return null;
        const url = new URL(href, location.href);
        return url.href;
    } catch { return null; }
}

async function gatherAISignals({ observeMs = 5000, whitelist = {} } = {}) {
    // Only consider strong signals: POSTs to known AI APIs OR large model downloads
    const aiEndpointPatterns = [
        // OpenAI
        /api\.openai\.com\/v1/i,
        // Anthropic
        /api\.anthropic\.com/i,
        // Google/Vertex
        /generativelanguage\.googleapis\.com/i,
        /aiplatform\.googleapis\.com/i,
        /vertex\.ai/i,
        // Azure OpenAI & Cognitive Services
        /openai\.azure\.com/i,
        /cognitiveservices\.azure\.com/i,
        /\/openai\/deployments\//i,
        // Cohere
        /api\.cohere\.ai/i,
        // Hugging Face
        /api-inference\.huggingface\.co/i,
        /huggingface\.co\/(api|models|inference)/i,
        // Replicate
        /api\.replicate\.com/i,
        // Stability
        /api\.stability\.ai/i
    ];
    const modelFileRe = /\.(onnx|tflite|safetensors|bin|gguf|pt|pth)(\?.*)?$/i;
    const ignoreResourceDomains = [
        /google-analytics\.com/i,
        /googletagmanager\.com/i,
        /doubleclick\.net/i,
        /facebook\.com\/(tr|plugins)/i,
        /connect\.facebook\.net/i,
        /linkedin\.com\/(analytics|li|px)/i,
        /twitter\.com\/i\/pixel/i,
        /cdnjs\.cloudflare\.com/i,
        /unpkg\.com/i,
        /jsdelivr\.net/i,
        /static\.hotjar\.com/i,
        /cdn\.segment\.com/i,
        /cdn\.amplitude\.com/i,
        /cdn\.mixpanel\.com/i
    ];

    const origin = (() => { try { return new URL(location.href).origin; } catch (e) { return location.origin; } })();
    if (whitelist && (whitelist[origin] || whitelist['*' + origin.slice(origin.indexOf('.'))])) {
        return { aiDetected: false, processing: 'unknown', signals: 0, details: {} };
    }

    // Ensure our passive observers exist
    try { if (!window.__aipgSignals) window.__aipgSignals = { posts: [], ws: [] }; } catch (e) { }

    // Wait for activity window
    await new Promise(resolve => setTimeout(resolve, observeMs));

    // Count POSTs to AI endpoints
    let aiPostCount = 0;
    try {
        const posts = (window.__aipgSignals && window.__aipgSignals.posts) || [];
        aiPostCount = posts.filter(p => aiEndpointPatterns.some(r => r.test(String(p.url || '')))).length;
    } catch (e) { }

    // Detect large model downloads (likely on-device inference)
    let largeModelCount = 0;
    try {
        const resEntries = (performance.getEntriesByType('resource') || []);
        for (const r of resEntries) {
            const name = r && r.name;
            if (!name || ignoreResourceDomains.some(rx => rx.test(name))) continue;
            // model file extensions or common model filename patterns
            const modelPattern = /model[-_]?weights|checkpoint|\.ggml(\?.*)?$/i;
            if (!(modelFileRe.test(name) || modelPattern.test(name))) continue;
            const size = (r.transferSize || r.encodedBodySize || 0);
            if (size > 5_000_000) largeModelCount++; // >5MB to cut tiny assets
        }
    } catch (e) { }

    // Optional passive endpoint sightings (not used to flip detection by themselves)
    let passiveEndpointSightings = 0;
    try {
        const resEntries = (performance.getEntriesByType('resource') || []);
        passiveEndpointSightings = resEntries.filter(r => aiEndpointPatterns.some(rx => rx.test(String(r && r.name || '')))).length;
    } catch { }

    // Optional WASM indicator count (transformer/tfjs/ort), does not flip detection
    let wasmIndicatorCount = 0;
    try {
        const wasmRx = /(ort[-_]?wasm|tfjs[-_]?backend[-_]?wasm|transformers?\.(wasm|js))/i;
        const resEntries = (performance.getEntriesByType('resource') || []);
        for (const r of resEntries) {
            const name = String(r && r.name || '');
            if (wasmRx.test(name)) {
                const size = (r.transferSize || r.encodedBodySize || 0);
                if (size > 1_000_000) wasmIndicatorCount++; // >1MB wasm/js
            }
        }
    } catch { }

    // Decision: require evidence of active POSTs or large model downloads
    const aiDetected = (aiPostCount > 0) || (largeModelCount > 0);
    const processing = aiPostCount > 0 ? 'cloud' : (largeModelCount > 0 ? 'on_device' : 'unknown');

    return {
        aiDetected,
        processing,
        signals: aiPostCount + largeModelCount,
        details: { aiPostCount, largeModelCount, passiveEndpointSightings, wasmIndicatorCount }
    };
}

async function collectPageAiContextWithObservation() {
    const { hasForm, creds } = detectFormsAndCredentials();
    const whitelist = await new Promise(resolve => chrome.storage.local.get(['aiWhitelist'], r => resolve(r.aiWhitelist || {})));
    const ai = await gatherAISignals({ observeMs: 5000, whitelist });
    let pageExcerpt = '';
    try {
        pageExcerpt = (document.body?.innerText || '').replace(/\s+/g, ' ').trim().slice(0, 4000);
    } catch { }

    const ctx = {
        site_url: location.href,
        context: {
            is_sensitive_category: detectSensitiveCategory(location.hostname, location.href),
            incognito: false,
            trackers_detected: detectTrackers(),
            model_download_gb: null,
            ai_detected: ai.aiDetected,
            ai_debug: ai.details,
            ai_signals: ai.signals,
        },
        ai_intent: 'summarize page text',
        data_scope: {
            page_text: true,
            forms: hasForm || false,
            credentials_fields: creds || false,
        },
        processing_location: ai.processing,
        policy_text_excerpt: null,
        change_diff: null,
        page_text_excerpt: pageExcerpt || null,
    };
    return ctx;
}

chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (msg && msg.type === 'GET_PAGE_AI_CONTEXT') {
        (async () => {
            try {
                const data = await collectPageAiContextWithObservation();
                let policyUrl = findPolicyLinkAbsolute();
                if (!policyUrl) {
                    try { policyUrl = await aiGuessPolicyLink(); } catch (e) { }
                }
                chrome.runtime.sendMessage({ type: 'FETCH_POLICY', url: policyUrl || undefined }, (res) => {
                    try {
                        if (res && res.success && typeof res.excerpt === 'string') {
                            data.policy_text_excerpt = res.excerpt;
                            if (res.url) data.policy_url = res.url;
                        }
                    } catch (e) { }
                    sendResponse({ success: true, data });
                });
            } catch (err) {
                sendResponse({ success: false, error: (err && err.message) || String(err) });
            }
        })();
        return true;
    }
    if (msg && msg.type === 'DETECT_AI_TEXT') {
        (async () => {
            try {
                const text = (document.body?.innerText || '').replace(/\s+/g, ' ').trim();
                if (!text) { sendResponse({ success: true, data: { overallScore: 0, details: [] } }); return; }
                // dynamic import of built service module (MV3-safe path)
                const mod = await import(chrome.runtime.getURL('services/textDetection.js'));
                const { detectAIText } = mod;
                const result = await detectAIText(text, { maxWordsPerChunk: 800, batchSize: 2 });
                sendResponse({ success: true, data: result });
            } catch (e) {
                sendResponse({ success: false, error: e?.message || String(e) });
            }
        })();
        return true;
    }
    if (msg && msg.type === 'FIND_POLICY_LINK') {
        try {
            const url = findPolicyLinkFromFooter() || (function () {
                const anchors = Array.from(document.querySelectorAll('a[href]'));
                const cand = anchors.find(a => /privacy[\s-]?policy|privacy|policy/i.test(a.textContent || '') || /privacy|privacy-policy/i.test(a.getAttribute('href') || ''));
                if (!cand) return null;
                const href = cand.getAttribute('href');
                if (!href) return null;
                try { return new URL(href, location.href).href; } catch (e) { return null; }
            })();
            sendResponse({ success: true, url: url || null });
        } catch (e) {
            sendResponse({ success: false, error: e?.message || String(e) });
        }
        return true;
    }
    if (msg && msg.type === 'ANALYZE_PRIVACY_POLICY') {
        (async () => {
            try {
                const mod = await import(chrome.runtime.getURL('services/policyAnalyzer.js'));
                const { analyzePrivacyPolicy } = mod;
                const result = await analyzePrivacyPolicy();
                sendResponse({ success: true, data: result });
            } catch (e) {
                sendResponse({ success: false, error: e?.message || String(e) });
            }
        })();
        return true;
    }
    if (msg && msg.type === 'READABILITY_EXTRACT') {
        (async () => {
            try {
                const { html, baseUrl } = msg;
                // dynamic import of extractor
                const mod = await import(chrome.runtime.getURL('services/readabilityExtract.js'));
                const { extractReadableFromHtml } = mod;
                const out = await extractReadableFromHtml(String(html || ''), String(baseUrl || location.href));
                sendResponse({ success: out.ok, data: out });
            } catch (e) {
                sendResponse({ success: false, error: e?.message || String(e) });
            }
        })();
        return true;
    }
});
// Smarter policy discovery: prefer footer links and score likely candidates
function findPolicyLinkFromFooter() {
    try {
        const containers = Array.from(document.querySelectorAll('footer, [role="contentinfo"], .footer'));
        const linkPatterns = [
            /privacy[\s-]?policy/i,
            /data[\s-]?protection/i,
            /privacy[\s-]?notice/i,
            /gdpr/i,
            /your[\s-]?privacy/i
        ];
        const candidates = [];
        for (const c of containers) {
            const anchors = Array.from(c.querySelectorAll('a[href]'));
            for (const a of anchors) {
                const text = (a.textContent || '').trim();
                const href = a.getAttribute('href') || '';
                if (!href || /^javascript:/i.test(href)) continue;
                if (linkPatterns.some(rx => rx.test(text) || rx.test(href))) {
                    let score = 0.5;
                    const lowerText = text.toLowerCase();
                    if (lowerText.includes('privacy policy')) score += 0.3;
                    else if (lowerText.includes('privacy')) score += 0.2;
                    if (/\/privacy/i.test(href)) score += 0.2;
                    candidates.push({ a, href, score });
                }
            }
        }
        candidates.sort((x, y) => y.score - x.score);
        if (candidates[0]) {
            const url = new URL(candidates[0].href, location.href);
            return url.href;
        }
        return null;
    } catch (e) { return null; }
}


function shouldShowBlockingModal(ctx) {
    try {
        const cats = detectSensitiveCategory(location.hostname, location.href);
        const sensitive = Array.isArray(cats) && cats.length > 0;
        const d = detectFormsAndCredentials();
        const anyHighSignals = d.hasForm || d.creds || ctx?.context?.trackers_detected || ctx?.processing_location !== 'on_device';
        return !!(sensitive && anyHighSignals);
    } catch (e) { return false; }
}

function createModal(onDecision) {
    const overlay = document.createElement('div');
    overlay.id = 'ai-privacy-guard-modal';
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.background = 'rgba(0,0,0,0.45)';
    overlay.style.zIndex = '2147483647';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';

    const panel = document.createElement('div');
    panel.style.background = '#fff';
    panel.style.borderRadius = '12px';
    panel.style.width = 'min(92vw, 520px)';
    panel.style.boxShadow = '0 10px 25px rgba(0,0,0,0.2)';
    panel.style.padding = '20px';
    panel.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

    const h = document.createElement('h2');
    h.textContent = 'AI Privacy Guard';
    h.style.margin = '0 0 8px 0';
    h.style.fontSize = '20px';
    h.style.fontWeight = '700';

    const p = document.createElement('p');
    p.textContent = "This looks sensitive. We're blocking AI by default. You can Allow once if needed.";
    p.style.margin = '0 0 14px 0';
    p.style.color = '#374151';
    p.style.fontSize = '14px';

    const btnRow = document.createElement('div');
    btnRow.style.display = 'flex';
    btnRow.style.gap = '8px';
    btnRow.style.marginTop = '12px';

    function makeBtn(label, bg, color) {
        const b = document.createElement('button');
        b.textContent = label;
        b.style.background = bg;
        b.style.color = color;
        b.style.border = 'none';
        b.style.padding = '10px 12px';
        b.style.borderRadius = '8px';
        b.style.cursor = 'pointer';
        b.style.fontWeight = '600';
        return b;
    }

    const allowOnce = makeBtn('Allow once', '#10B981', '#fff');
    const askEvery = makeBtn('Ask every time', '#3B82F6', '#fff');
    const block = makeBtn('Block', '#EF4444', '#fff');

    allowOnce.addEventListener('click', () => onDecision('allow_once'));
    askEvery.addEventListener('click', () => onDecision('ask'));
    block.addEventListener('click', () => onDecision('block'));

    btnRow.appendChild(allowOnce);
    btnRow.appendChild(askEvery);
    btnRow.appendChild(block);

    panel.appendChild(h);
    panel.appendChild(p);
    panel.appendChild(btnRow);
    overlay.appendChild(panel);

    return { overlay };
}

function getOrigin(u) {
    try { const x = new URL(u); return x.origin; } catch (e) { return location.origin; }
}

async function ensureSiteDecision(ctx) {
    const origin = getOrigin(ctx.site_url);
    return new Promise((resolve) => {
        chrome.storage.local.get(['siteDecisions'], (res) => {
            const map = res.siteDecisions || {};
            resolve(map[origin] || null);
        });
    });
}

async function saveSiteDecision(ctx, decision) {
    const origin = getOrigin(ctx.site_url);
    return new Promise((resolve) => {
        chrome.storage.local.get(['siteDecisions', 'allowMinutes'], (res) => {
            const map = res.siteDecisions || {};
            const allowMs = Math.max(1, Number(res.allowMinutes || 5)) * 60 * 1000;
            map[origin] = {
                mode: decision,
                ts: Date.now(),
                expiresAt: decision === 'allow_once' ? Date.now() + allowMs : null
            };
            chrome.storage.local.set({ siteDecisions: map }, () => resolve(true));
        });
    });
}

function notifyLog(entry) {
    try { chrome.runtime.sendMessage({ type: 'LOG_EVENT', entry }); } catch (e) { }
}

async function maybeShowBlockingModal() {
    try {
        const ctx = await collectPageAiContextWithObservation();
        const dec = await ensureSiteDecision(ctx);
        const origin = getOrigin(ctx.site_url);
        // Respect allow_once expiry
        if (dec && dec.mode === 'allow_once' && dec.expiresAt && dec.expiresAt > Date.now()) {
            notifyLog({ kind: 'modal_skip_allow_once', origin, time: Date.now() });
            return; // allowed for now
        }
        if (dec && dec.mode === 'block') {
            notifyLog({ kind: 'modal_skip_block', origin, time: Date.now() });
            return;
        }
        if (!shouldShowBlockingModal(ctx)) return;

        // Apply sensitive default behavior
        const { sensitiveDefault } = await new Promise((resolve) => {
            chrome.storage.local.get(['sensitiveDefault'], (r) => resolve({ sensitiveDefault: r.sensitiveDefault || 'block' }));
        });
        if (!dec && sensitiveDefault === 'block') {
            await saveSiteDecision(ctx, 'block');
            notifyLog({ kind: 'modal_auto_block', origin, time: Date.now() });
            return;
        }

        const { overlay } = createModal(async (choice) => {
            await saveSiteDecision(ctx, choice);
            document.body.removeChild(overlay);
            notifyLog({ kind: 'modal_choice', choice, origin, time: Date.now() });
        });
        document.body.appendChild(overlay);
        notifyLog({ kind: 'modal_shown', origin, time: Date.now() });
    } catch (e) {
        // best-effort
    }
}

// Show modal on first load if needed
try {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', maybeShowBlockingModal);
    } else {
        maybeShowBlockingModal();
    }
} catch (e) { }

// Lightweight UI helpers
function buildOutboundMaskUI(original, rewritten, redactions) {
    try {
        if (!original || !redactions || redactions.length === 0) return null;
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = 'rgba(0,0,0,0.35)';
        overlay.style.zIndex = '2147483647';
        const panel = document.createElement('div');
        panel.style.position = 'fixed';
        panel.style.right = '20px';
        panel.style.bottom = '20px';
        panel.style.width = 'min(92vw, 520px)';
        panel.style.maxHeight = '60vh';
        panel.style.overflow = 'auto';
        panel.style.background = '#fff';
        panel.style.border = '1px solid #e5e7eb';
        panel.style.borderRadius = '12px';
        panel.style.boxShadow = '0 10px 25px rgba(0,0,0,0.15)';
        panel.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
        panel.style.padding = '12px';

        const title = document.createElement('div');
        title.textContent = 'Review before sending';
        title.style.fontWeight = '700';
        title.style.marginBottom = '6px';

        const list = document.createElement('ul');
        list.style.fontSize = '12px';
        list.style.color = '#374151';
        list.style.paddingLeft = '18px';
        redactions.slice(0, 8).forEach(r => {
            const li = document.createElement('li');
            li.textContent = `${r.type}: ${String(r.value).slice(0, 64)}`;
            list.appendChild(li);
        });
        if (redactions.length > 8) {
            const more = document.createElement('div');
            more.textContent = `+${redactions.length - 8} more…`;
            more.style.fontSize = '11px'; more.style.color = '#6b7280'; more.style.marginTop = '4px';
            panel.appendChild(more);
        }

        const btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        btnRow.style.marginTop = '10px';
        const send = document.createElement('button');
        send.textContent = 'Send with masking';
        send.style.background = '#10B981'; send.style.color = '#fff';
        send.style.border = 'none'; send.style.padding = '8px 10px'; send.style.borderRadius = '8px';
        const cancel = document.createElement('button');
        cancel.textContent = 'Cancel';
        cancel.style.background = '#ef4444'; cancel.style.color = '#fff';
        cancel.style.border = 'none'; cancel.style.padding = '8px 10px'; cancel.style.borderRadius = '8px';

        const preview = document.createElement('div');
        preview.style.background = '#F9FAFB'; preview.style.border = '1px dashed #e5e7eb';
        preview.style.padding = '8px'; preview.style.marginTop = '8px'; preview.style.fontSize = '12px';
        preview.style.whiteSpace = 'pre-wrap';
        try {
            const show = typeof rewritten === 'string' ? rewritten : JSON.stringify(rewritten, null, 2);
            preview.textContent = show.slice(0, 1000);
        } catch { }

        btnRow.appendChild(send); btnRow.appendChild(cancel);
        panel.appendChild(title);
        panel.appendChild(list);
        panel.appendChild(preview);
        panel.appendChild(btnRow);
        overlay.appendChild(panel);
        document.documentElement.appendChild(overlay);

        return {
            waitForDecision() {
                return new Promise((resolve) => {
                    send.addEventListener('click', () => resolve('send'));
                    cancel.addEventListener('click', () => resolve('cancel'));
                });
            },
            cleanup() { try { overlay.remove(); } catch (e) { } }
        };
    } catch (e) { return null; }
}

function renderInboundSignalBanner(ok) {
    try {
        const id = '__aipg_inbound_banner';
        let bar = document.getElementById(id);
        if (!bar) {
            bar = document.createElement('div');
            bar.id = id;
            bar.style.position = 'fixed';
            bar.style.left = '20px';
            bar.style.bottom = '20px';
            bar.style.zIndex = '2147483647';
            bar.style.padding = '6px 10px';
            bar.style.borderRadius = '9999px';
            bar.style.fontSize = '12px';
            bar.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
            document.documentElement.appendChild(bar);
        }
        const text = document.createElement('span');
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = ' View details';
        link.style.marginLeft = '8px';
        link.style.textDecoration = 'underline';
        link.style.cursor = 'pointer';
        link.addEventListener('click', (e) => {
            e.preventDefault();
            try { const url = chrome.runtime.getURL('popup.html') + '?advanced=1'; chrome.runtime.sendMessage({ type: 'OPEN_POPUP_WINDOW' }); window.open(url, '_blank', 'noopener,noreferrer,width=420,height=640'); } catch (e) { }
        });
        if (ok) {
            text.textContent = 'AI Privacy Guard: Response looks safe';
            bar.style.background = '#DCFCE7'; bar.style.color = '#065F46'; bar.style.border = '1px solid #bbf7d0';
        } else {
            text.textContent = 'AI Privacy Guard: Risky content detected';
            bar.style.background = '#FEE2E2'; bar.style.color = '#7F1D1D'; bar.style.border = '1px solid #fecaca';
        }
        bar.textContent = '';
        bar.appendChild(text);
        bar.appendChild(link);
        setTimeout(() => { try { bar.remove(); } catch (e) { } }, 5000);
    } catch (e) { }
}



background.js-


// background.js

const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models";

// ---------------- Local Memory (ChatGPT-specific) ----------------
const MEMORY_KEY = 'aipgMemoryRecords';
const PII_INDEX_KEY = 'aipgPiiIndex'; // { [sessionId]: { link, site, lastTs, items: Array<{ id, ts, counts }> } }
let __writeQueue = [];
let __writeTimer = null;

function validateMemoryRecord(r) {
    try {
        if (!r || typeof r !== 'object') return false;
        if (!r.id || typeof r.id !== 'string') return false;
        if (!r.ts || typeof r.ts !== 'number') return false;
        if (!r.site || typeof r.site !== 'string') return false;
        if (!r.conversationUrl || typeof r.conversationUrl !== 'string') return false;
        if (r.direction !== 'prompt' && r.direction !== 'response') return false;
        if (typeof r.excerpt !== 'string') return false;
        if (r.direction === 'prompt') {
            // rawAllowed required for prompt, piiCounts object expected
            if (typeof r.rawAllowed !== 'boolean') return false;
            if (!r.piiCounts || typeof r.piiCounts !== 'object') r.piiCounts = { EMAIL: 0, PHONE: 0, CARD: 0, APIKEY: 0 };
        }
        // clamp sizes
        if (r.direction === 'prompt') r.excerpt = String(r.excerpt).slice(0, 240);
        if (r.direction === 'response') r.excerpt = String(r.excerpt).slice(0, 500);
        return true;
    } catch { return false; }
}

function flushMemoryQueue() {
    clearTimeout(__writeTimer); __writeTimer = null;
    const batch = __writeQueue.splice(0, __writeQueue.length);
    if (batch.length === 0) return;
    chrome.storage.local.get([MEMORY_KEY], (res) => {
        const arr = Array.isArray(res[MEMORY_KEY]) ? res[MEMORY_KEY] : [];
        const next = arr.concat(batch);
        // keep only most recent 500
        next.sort((a, b) => a.ts - b.ts);
        const capped = next.slice(Math.max(0, next.length - 500));
        chrome.storage.local.set({ [MEMORY_KEY]: capped });
    });
}

function queueMemoryWrite(record) {
    if (!validateMemoryRecord(record)) return false;
    __writeQueue.push(record);
    // In MV3 service workers, timers can be unreliable due to suspension.
    // Flush immediately to ensure durability.
    if (__writeTimer) { clearTimeout(__writeTimer); __writeTimer = null; }
    flushMemoryQueue();
    return true;
}

async function getApiKey() {
    return new Promise((resolve) => {
        chrome.storage.local.get(["GEMINI_API_KEY"], (result) => {
            resolve(result.GEMINI_API_KEY || null);
        });
    });
}

// --- Local 7-day logs ---
function withLogs(cb) {
    chrome.storage.local.get(['aiLogs', 'retentionDays'], (res) => {
        const now = Date.now();
        const days = (typeof res.retentionDays === 'number' ? res.retentionDays : 7);
        const windowMs = days * 24 * 60 * 60 * 1000;
        const arr = (res.aiLogs || []).filter((e) => e && e.time && (now - e.time) <= windowMs);
        cb(arr);
    });
}
function saveLogs(arr, done) {
    chrome.storage.local.set({ aiLogs: arr }, done);
}

// Minimal PII redaction for any outbound cloud prompts
function redactPII(text) {
    try {
        if (typeof text !== 'string') return text;
        let t = text;
        // Emails
        t = t.replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi, '[REDACTED:EMAIL]');
        // Phone numbers (US-style variants)
        t = t.replace(/\b(?:\+?1[-.\s]?)?(?:\(\d{3}\)|\d{3})[-.\s]?\d{3}[-.\s]?\d{4}\b/g, '[REDACTED:PHONE]');
        // SSN
        t = t.replace(/\b\d{3}-\d{2}-\d{4}\b/g, '[REDACTED:SSN]');
        // Credit/Debit card numbers (13-19 digits, allowing spaces/dashes)
        t = t.replace(/\b(?:\d[ -]*?){13,19}\b/g, '[REDACTED:CARD]');
        // IPv4
        t = t.replace(/\b(?:\d{1,3}\.){3}\d{1,3}\b/g, '[REDACTED:IP]');
        // Government/ID numbers (heuristic)
        t = t.replace(/\b(passport|driver'?s?\s*license|dl\s*number|national\s*id)[:#]?\s*[A-Z0-9-]+\b/gi, '[REDACTED:ID]');
        // Strip URL query strings to avoid leaking tokens/ids
        t = t.replace(/https?:\/\/[^\s"']+/gi, (m) => {
            try {
                const u = new URL(m);
                return `${u.origin}${u.pathname}`; // drop search/hash
            } catch {
                return m;
            }
        });
        return t;
    } catch {
        return text;
    }
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    // Memory API (list, write, delete, purge)
    if (message && message.type === 'MEMORY_WRITE') {
        try {
            const ok = queueMemoryWrite(message.record);
            sendResponse({ success: ok });
        } catch (e) {
            sendResponse({ success: false, error: e?.message || 'write-failed' });
        }
        return true;
    }
    if (message && message.type === 'MEMORY_LIST') {
        chrome.storage.local.get([MEMORY_KEY], (res) => {
            sendResponse({ success: true, records: Array.isArray(res[MEMORY_KEY]) ? res[MEMORY_KEY] : [] });
        });
        return true;
    }
    if (message && message.type === 'MEMORY_DELETE') {
        const id = message.id;
        chrome.storage.local.get([MEMORY_KEY], (res) => {
            const arr = Array.isArray(res[MEMORY_KEY]) ? res[MEMORY_KEY] : [];
            const next = arr.filter(r => r && r.id !== id);
            chrome.storage.local.set({ [MEMORY_KEY]: next }, () => sendResponse({ success: true }));
        });
        return true;
    }
    if (message && message.type === 'MEMORY_PURGE') {
        chrome.storage.local.set({ [MEMORY_KEY]: [], [PII_INDEX_KEY]: {} }, () => sendResponse({ success: true }));
        return true;
    }
    if (message && message.type === 'PII_FOUND') {
        try {
            const { chatId, messageId, link, site, counts } = message;
            if (!chatId || !messageId || !link) { sendResponse({ success: false, error: 'bad-args' }); return true; }
            chrome.storage.local.get([PII_INDEX_KEY], (res) => {
                const map = (res && res[PII_INDEX_KEY]) || {};
                const rec = map[chatId] || { link, site: site || null, lastTs: 0, items: [] };
                rec.link = link; if (site) rec.site = site;
                rec.items.push({ id: messageId, ts: Date.now(), counts: counts || null });
                rec.lastTs = Date.now();
                map[chatId] = rec;
                chrome.storage.local.set({ [PII_INDEX_KEY]: map }, () => sendResponse({ success: true }));
            });
        } catch (e) { sendResponse({ success: false, error: e?.message || 'pii-found-failed' }); }
        return true;
    }
    if (message && message.type === 'PII_INDEX_LIST') {
        chrome.storage.local.get([PII_INDEX_KEY], (res) => {
            sendResponse({ success: true, data: res && res[PII_INDEX_KEY] ? res[PII_INDEX_KEY] : {} });
        });
        return true;
    }
    if (message.type === 'BOT_DETECT') {
        (async () => {
            try {
                // Run in the page context to access navigator/window signals
                const tabId = sender?.tab?.id;
                if (!tabId) throw new Error('No active tab for bot detection');
                const [{ result }] = await chrome.scripting.executeScript({
                    target: { tabId },
                    func: async () => {
                        try {
                            const anyGlobal = globalThis;
                            // Inline minimal heuristic + optional global botd
                            async function detect() {
                                try {
                                    if (anyGlobal && anyGlobal.botd && typeof anyGlobal.botd.load === 'function') {
                                        const botd = await anyGlobal.botd.load();
                                        const r = await botd.detect();
                                        const bot = r?.bot || {};
                                        const isBot = String(bot.result || '').toLowerCase() === 'bot';
                                        const confidence = typeof bot.probability === 'number' ? Math.max(0, Math.min(1, bot.probability)) : (isBot ? 0.8 : 0.6);
                                        return { isBot, confidence, signals: { type: bot.type, probability: bot.probability, requestId: r?.requestId, raw: bot } };
                                    }
                                } catch { }

                                const nav = navigator;
                                const signals = {
                                    webdriver: !!nav.webdriver,
                                    pluginsLength: (nav.plugins && nav.plugins.length) || 0,
                                    languagesLength: (nav.languages && nav.languages.length) || 0,
                                    hardwareConcurrency: (nav.hardwareConcurrency || 0),
                                    deviceMemory: (nav.deviceMemory || 0),
                                    userAgent: (nav.userAgent || ''),
                                };
                                let score = 0;
                                if (signals.webdriver) score += 0.6;
                                if (signals.pluginsLength === 0) score += 0.1;
                                if (signals.languagesLength === 0) score += 0.1;
                                if (/headless|puppeteer|playwright/i.test(signals.userAgent)) score += 0.6;
                                const isBot = score >= 0.6;
                                const confidence = Math.max(0.2, Math.min(1, score));
                                return { isBot, confidence, signals };
                            }
                            return await detect();
                        } catch (e) {
                            return { isBot: false, confidence: 0.5, signals: { error: e?.message || 'botd-failed' } };
                        }
                    },
                });
                sendResponse({ success: true, data: result });
            } catch (err) {
                sendResponse({ success: false, error: err?.message || String(err) });
            }
        })();
        return true;
    }
    if (message.type === 'SUMMARIZE_POLICY_ONDEVICE') {
        (async () => {
            try {
                const { excerpt } = message;
                if (!excerpt || typeof excerpt !== 'string' || !excerpt.trim()) {
                    sendResponse({ success: true, summary: 'No clear privacy/AI policy found. This can be risky.' });
                    return;
                }
                // Placeholder for Chrome on-device AI (if exposed in the future).
                // For now, just return the first 3 heuristic bullets similarly to rulesEngine.
                const text = excerpt.replace(/\s+/g, ' ').trim();
                const points = [];
                if (/do\s+not\s+sell|don't\s+sell|opt[- ]?out/i.test(text)) points.push('Mentions opt-out or “do not sell” options.');
                if (/third[- ]?part(y|ies)|share with/i.test(text)) points.push('Shares data with third parties.');
                if (/retain|retention|store for/i.test(text)) points.push('Specifies data retention.');
                if (/advertis|marketing|personaliz/i.test(text)) points.push('Uses data for advertising/marketing.');
                if (/ai|machine\s*learning|model/i.test(text)) points.push('References AI/model usage.');
                if (/cookie|tracking|analytics/i.test(text)) points.push('Mentions cookies/analytics tracking.');
                const out = points.slice(0, 3).join(' ');
                sendResponse({ success: true, summary: out || text.slice(0, 300) });
            } catch (err) {
                sendResponse({ success: false, error: err?.message || String(err) });
            }
        })();
        return true;
    }
    if (message.type === 'LOG_EVENT') {
        withLogs((arr) => {
            arr.push(message.entry);
            saveLogs(arr, () => sendResponse({ success: true }));
        });
        return true;
    }
    if (message.type === 'EXPORT_LOGS') {
        withLogs((arr) => {
            sendResponse({ success: true, data: arr });
        });
        return true;
    }
    if (message.type === 'FETCH_POLICY') {
        (async () => {
            try {
                const policyUrl = (message && typeof message.url === 'string' && message.url) || null;
                const siteUrl = (message && typeof message.siteUrl === 'string' && message.siteUrl) || null;
                const full = !!(message && message.full);
                const origin = (() => {
                    try {
                        if (siteUrl) return new URL(siteUrl).origin;
                        return new URL(sender?.url || '').origin;
                    } catch { return null; }
                })();

                // Guard: only allow http/https
                const isHttp = (u) => {
                    try { const x = new URL(u); return x.protocol === 'http:' || x.protocol === 'https:'; } catch { return false; }
                };
                if ((policyUrl && !isHttp(policyUrl)) || (origin && !isHttp(origin + '/'))) {
                    sendResponse({ success: true, excerpt: '', url: null, skipped: true });
                    return;
                }

                // Simple cache (24h TTL) keyed by URL or origin
                const cacheKey = policyUrl || `${origin}/__auto_policy`;
                const cache = await new Promise(resolve => chrome.storage.local.get(['policyCache'], res => resolve(res.policyCache || {})));
                const cached = cache[cacheKey];
                const ttlMs = 24 * 60 * 60 * 1000;
                if (cached && cached.ts && (Date.now() - cached.ts) < ttlMs) {
                    sendResponse({ success: true, excerpt: cached.excerpt, cached: true });
                    return;
                }

                // Helper: fetch a URL and extract readable text
                async function fetchAndExtract(u) {
                    const res = await fetch(u, { method: 'GET' });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const html = await res.text();
                    // Remove scripts/styles/noscript
                    let t = html.replace(/<script[\s\S]*?<\/script>/gi, ' ')
                        .replace(/<style[\s\S]*?<\/style>/gi, ' ')
                        .replace(/<noscript[\s\S]*?<\/noscript>/gi, ' ');
                    // Keep headings and paragraphs markers to preserve boundaries
                    t = t.replace(/<\/(h1|h2|h3|p|li)>/gi, '\n')
                        .replace(/<br\s*\/?>/gi, '\n');
                    // Strip all other tags
                    t = t.replace(/<[^>]+>/g, ' ');
                    // Decode a few common entities
                    t = t.replace(/&nbsp;/g, ' ').replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
                    // Collapse whitespace
                    t = t.replace(/[\t\r]+/g, ' ').replace(/\s*\n\s*/g, '\n').replace(/\n{2,}/g, '\n').replace(/\s{2,}/g, ' ').trim();
                    // Focus around typical headings
                    const lower = t.toLowerCase();
                    const markers = ['privacy policy', 'privacy notice', 'data protection', 'política de privacidad', 'politique de confidentialité', 'datenschutz'];
                    let start = 0;
                    for (const m of markers) {
                        const i = lower.indexOf(m);
                        if (i >= 0) { start = Math.max(0, i - 200); break; }
                    }
                    const excerpt = t.slice(start, start + 4000); // up to ~4k chars for better summary
                    const fullText = t.slice(0, 100000); // cap ~100k chars
                    return { excerpt, fullText };
                }

                async function discoverPolicyFromOrigin() {
                    if (!origin) throw new Error('No origin and URL provided');
                    if (!isHttp(origin + '/')) throw new Error('Non-http origin');
                    const bases = [origin];
                    const paths = [
                        '/privacy', '/privacy-policy', '/legal/privacy',
                        '/policies/privacy', '/privacy.html', '/privacypolicy',
                        '/terms/privacy', '/legal', '/terms-and-privacy',
                        '/privacy-notice', '/data-protection', '/gdpr',
                        '/en/privacy', '/en/privacy-policy', '/policy/privacy'
                    ];
                    for (const b of bases) {
                        for (const p of paths) {
                            const u = b + p;
                            try {
                                const ex = await fetchAndExtract(u);
                                return { url: u, excerpt: ex.excerpt, fullText: ex.fullText };
                            } catch (_) { /* try next */ }
                        }
                    }
                    throw new Error('Policy not found via auto-discovery');
                }

                let finalUrl = policyUrl;
                let excerpt;
                let fullText;
                try {
                    if (finalUrl) {
                        const data = await fetchAndExtract(finalUrl);
                        excerpt = data.excerpt;
                        fullText = data.fullText;
                    } else {
                        const found = await discoverPolicyFromOrigin();
                        finalUrl = found.url;
                        excerpt = found.excerpt;
                        fullText = found.fullText;
                    }
                } catch (e) {
                    // Last resort: return empty excerpt
                    excerpt = '';
                    fullText = '';
                }

                // Save cache
                try {
                    const k = finalUrl || cacheKey;
                    const next = Object.assign({}, cache, { [k]: { ts: Date.now(), excerpt, fullText } });
                    chrome.storage.local.set({ policyCache: next }, () => { });
                } catch { }

                const payload = { success: true, excerpt, url: finalUrl };
                if (full) payload.fullText = fullText;
                sendResponse(payload);
            } catch (err) {
                sendResponse({ success: false, error: err?.message || String(err) });
            }
        })();
        return true;
    }
    if (message.type === 'CLEAR_LOGS') {
        saveLogs([], () => sendResponse({ success: true }));
        return true;
    }
    if (message.type === "TEST_GEMINI_KEY") {
        (async () => {
            try {
                const apiKey = await getApiKey();
                if (!apiKey) throw new Error("Missing Gemini API key.");
                const url = `${GEMINI_API_URL}?key=${apiKey}`; // GET models listing
                const res = await fetch(url, { method: "GET" });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data.error?.message || `HTTP ${res.status}`);
                sendResponse({ success: true });
            } catch (err) {
                sendResponse({ success: false, error: err.message || String(err) });
            }
        })();
        return true;
    }
    if (message.type === "CALL_GEMINI") {
        (async () => {
            try {
                const apiKey = await getApiKey();
                if (!apiKey) {
                    throw new Error("Missing Gemini API key. Set it in extension settings.");
                }
                const { model, prompt, systemInstruction, responseSchema, site_url, is_sensitive } = message;

                // Cloud toggle
                const { cloudEnabled } = await new Promise((resolve) => {
                    chrome.storage.local.get(['cloudEnabled'], (res) => resolve({ cloudEnabled: !!res.cloudEnabled }));
                });
                if (!cloudEnabled) {
                    throw new Error('Cloud analysis disabled in settings.');
                }

                // Enforcement: block cloud calls on sensitive sites unless explicitly allowed once
                const origin = (() => { try { return new URL(site_url || '').origin; } catch { return null; } })();
                if (is_sensitive && origin) {
                    const decision = await new Promise((resolve) => {
                        chrome.storage.local.get(['siteDecisions', 'allowMinutes', 'sensitiveDefault'], (res) => {
                            const map = res.siteDecisions || {};
                            const d = map[origin] || null;
                            const allowMs = Math.max(1, Number(res.allowMinutes || 5)) * 60 * 1000;
                            if (d && d.mode === 'allow_once' && d.ts && (Date.now() - d.ts) <= allowMs) {
                                resolve({ mode: 'allow_once', expiresAt: d.ts + allowMs });
                                return;
                            }
                            resolve(d || { mode: res.sensitiveDefault === 'ask' ? 'ask' : 'block' });
                        });
                    });
                    const d = decision || {};
                    const allowOnceActive = d.mode === 'allow_once' && d.expiresAt && d.expiresAt > Date.now();
                    if (!allowOnceActive) {
                        throw new Error('Cloud processing blocked by policy for this sensitive site. Use Allow once.');
                    }
                }

                const url = `${GEMINI_API_URL}/${model}:generateContent?key=${apiKey}`;

                const body = {
                    contents: [
                        { role: "user", parts: [{ text: redactPII(String(prompt || '')) }] }
                    ],
                    systemInstruction: {
                        role: "system",
                        parts: [{ text: systemInstruction }]
                    }
                    ,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema
                    }
                };

                const res = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error?.message || "Gemini API error");
                }

                // Parse JSON response safely
                let parsed;
                try {
                    parsed = JSON.parse(data?.candidates?.[0]?.content?.parts?.[0]?.text || '{}');
                } catch (err) {
                    throw new Error("Failed to parse Gemini JSON output");
                }

                sendResponse({ success: true, data: parsed });
            } catch (err) {
                sendResponse({ success: false, error: err.message });
            }
        })();

        return true; // async
    }
});